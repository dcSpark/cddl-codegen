"use strict";(self.webpackChunkcddl_codegen_documentation=self.webpackChunkcddl_codegen_documentation||[]).push([[163],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1217:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:7},i="Comment DSL",l={unversionedId:"comment_dsl",id:"comment_dsl",title:"Comment DSL",description:"We have a comment DSL to help annotate the output code beyond what is possible just with CDDL.",source:"@site/docs/comment_dsl.mdx",sourceDirName:".",slug:"/comment_dsl",permalink:"/cddl-codegen/comment_dsl",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Wasm Differences",permalink:"/cddl-codegen/wasm_differences"},next:{title:"Examples",permalink:"/cddl-codegen/examples"}},s={},p=[{value:"@name",id:"name",level:2},{value:"@newtype",id:"newtype",level:2},{value:"@no_alias",id:"no_alias",level:2},{value:"@used_as_key",id:"used_as_key",level:2},{value:"<em>CDDL_CODEGEN_EXTERN_TYPE</em>",id:"cddl_codegen_extern_type",level:2},{value:"<em>CDDL_CODEGEN_RAW_BYTES_TYPE</em>",id:"cddl_codegen_raw_bytes_type",level:2}],d={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"comment-dsl"},"Comment DSL"),(0,r.kt)("p",null,"We have a comment DSL to help annotate the output code beyond what is possible just with CDDL."),(0,r.kt)("h2",{id:"name"},"@name"),(0,r.kt)("p",null,"For example in an array-encoded group you can give explicit names just by the keys e.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = [\n    bar: uint,\n    baz: text\n]\n")),(0,r.kt)("p",null,"but with map-encoded structs the keys are stored and for things like integer keys this isn't very helpful e.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"tx = {\n  ? 0: [* input],\n  ? 1: [* outputs],\n}\n")),(0,r.kt)("p",null,"we would end up with two fields: ",(0,r.kt)("inlineCode",{parentName:"p"},"key_0")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"key_1"),". We can instead end up with fields named ",(0,r.kt)("inlineCode",{parentName:"p"},"inputs")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"outputs")," by doing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"tx = {\n  ? 0: [* input],   ; @name inputs\n  ? 1: [* outputs], ; @name outputs\n}\n")),(0,r.kt)("p",null,"Note: the parsing can be finicky. For struct fields you must put the comment AFTER the comma, and the comma must exist even for the last field in a struct."),(0,r.kt)("p",null,"It is also possible to use ",(0,r.kt)("inlineCode",{parentName:"p"},"@name")," with type choices:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = 0 ; @name mainnet\n    / 1 ; @name testnet\n")),(0,r.kt)("p",null,"and also for group choices:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"script = [\n  ; @name native\n  tag: 0, script: native_script //\n  ; @name plutus_v1\n  tag: 1, script: plutus_v1_script //\n  ; @name plutus_v2\n  tag: 2, script: plutus_v2_script\n]\n")),(0,r.kt)("h2",{id:"newtype"},"@newtype"),(0,r.kt)("p",null,"With code like ",(0,r.kt)("inlineCode",{parentName:"p"},"foo = uint")," this creates an alias e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"pub type Foo = u64;")," in rust. When we use ",(0,r.kt)("inlineCode",{parentName:"p"},"foo = uint ; @newtype")," it instead creates a ",(0,r.kt)("inlineCode",{parentName:"p"},"pub struct Foo(u64);"),"."),(0,r.kt)("h2",{id:"no_alias"},"@no_alias"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = uint\nbar = [\n  field: foo\n]\n")),(0,r.kt)("p",null,"This would normally result in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub type Foo = u64;\npub struct Bar {\n    field: Foo,\n}\n")),(0,r.kt)("p",null,"but if we use ",(0,r.kt)("inlineCode",{parentName:"p"},"@no_alias")," it skips generating an alias and uses it directly e.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = uint ; @no_alias\nbar = [\n  field: foo\n]\n")),(0,r.kt)("p",null,"to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct Bar {\n    field: u64,\n}\n")),(0,r.kt)("h2",{id:"used_as_key"},"@used_as_key"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = [\n  x: uint,\n  y: uint,\n] ; @used_as_Key\n")),(0,r.kt)("p",null,"cddl-codegen automatically derives ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"PartialOrd")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Hash")," for any types used within as a key in another type.\nPutting this comment on a type forces that type to derive those traits even if it weren't used in a key in the cddl spec.\nThis is useful for when you are writing utility code that would put them in a map and want the generated code to have it already,\nwhich is particularly useful for re-generating as it lets your ",(0,r.kt)("inlineCode",{parentName:"p"},"mod.rs")," files remain untouched."),(0,r.kt)("h2",{id:"cddl_codegen_extern_type"},(0,r.kt)("em",{parentName:"h2"},"CDDL_CODEGEN_EXTERN_TYPE")),(0,r.kt)("p",null,"While not as a comment, this allows you to compose in hand-written structs into a cddl spec."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = _CDDL_CODEGEN_EXTERN_TYPE_\nbar = [\n    x: uint,\n    y: foo,\n]\n")),(0,r.kt)("p",null,"This will treat ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," as a type that will exist and that has implemented the ",(0,r.kt)("inlineCode",{parentName:"p"},"Serialize")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Deserialize")," traits, so the (de)serialization logic in ",(0,r.kt)("inlineCode",{parentName:"p"},"Bar")," here will call ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo::serialize()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo::deserialize()"),".\nThis can also be useful when you have a spec that is either very awkward to use (so you hand-write or hand-modify after generation) in some type so you don't generate those types and instead manually merge those hand-written/hand-modified structs back in to the code afterwards. This saves you from having to manually remove all code that is generated regarding ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," first before merging in your own."),(0,r.kt)("p",null,"This can also be useful when you have a spec that is either very awkward to use (so you hand-write or hand-modify after generation) in some type so you don't generate those types and instead manually merge those hand-written/hand-modified structs back in to the code afterwards. This saves you from having to manually remove all code that is generated regarding ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," first before merging in your own."),(0,r.kt)("h2",{id:"cddl_codegen_raw_bytes_type"},(0,r.kt)("em",{parentName:"h2"},"CDDL_CODEGEN_RAW_BYTES_TYPE")),(0,r.kt)("p",null,"Allows encoding as ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes")," but imposing hand-written constraints defined elsewhere."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cddl"},"foo = _CDDL_CODEGEN_RAW_BYTES_TYPE_\nbar = [\n    foo,\n]\n")),(0,r.kt)("p",null,"This will treat ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," as some external type called ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo"),". This type must implement the exported (in ",(0,r.kt)("inlineCode",{parentName:"p"},"serialization.rs"),") trait ",(0,r.kt)("inlineCode",{parentName:"p"},"RawBytesEncoding"),".\nThis can be useful for example when working with cryptographic primtivies e.g. a hash or pubkey, as it allows users to have those crypto structs be from a crypto library then they only need to implement the trait for them and they will be able to be directly used without needing any useless generated wrapper struct for the in between."))}c.isMDXComponent=!0}}]);