static NULL: u8 = 0xf6;
static BREAK: u8 = 0xff;
static ARR_INDEF: u8 = 0x9f;
static MAP_INDEF: u8 = 0xbf;

fn arr_def(len: u8) -> Vec<u8> {
    assert!(len <= 0x17);
    vec![0x80u8 + len]
}

fn map_def(len: u8) -> Vec<u8> {
    assert!(len <= 0x17);
    vec![0xa0 + len]
}

fn arr_sz(len: u64, sz: cbor_event::Sz) -> Vec<u8> {
    let mut buf = cbor_event::se::Serializer::new_vec();
    buf.write_array_sz(cbor_event::LenSz::Len(len, sz)).unwrap();
    buf.finalize()
}

fn map_sz(len: u64, sz: cbor_event::Sz) -> Vec<u8> {
    let mut buf = cbor_event::se::Serializer::new_vec();
    buf.write_map_sz(cbor_event::LenSz::Len(len, sz)).unwrap();
    buf.finalize()
}

fn cbor_string(s: &str) -> Vec<u8> {
    // our keys are short so we don't handle bigger ones
    assert!(s.len() <= 0x17);
    let mut bytes = Vec::with_capacity(s.len() + 1);
    bytes.push(0x60u8 + s.len() as u8);
    bytes.extend_from_slice(s.as_bytes());
    bytes
}

fn cbor_tag(t: u8) -> Vec<u8> {
    assert!(t <= 0xd4 - 0xc0);
    vec![0xc0u8 + t]
}

fn cbor_int(x: i128, sz: cbor_event::Sz) -> Vec<u8> {
    let mut buf = cbor_event::se::Serializer::new_vec();
    if x >= 0 {
        buf.write_unsigned_integer_sz(x as u64, sz).unwrap();
    } else {
        buf.write_negative_integer_sz(x, sz).unwrap();
    }
    buf.finalize()
}

fn cbor_tag_sz(tag: u64, sz: cbor_event::Sz) -> Vec<u8> {
    let mut buf = cbor_event::se::Serializer::new_vec();
    buf.write_tag_sz(tag, sz).unwrap();
    buf.finalize()
}

fn cbor_str_sz(s: &str, sz: cbor_event::StringLenSz) -> Vec<u8> {
    let mut buf = cbor_event::se::Serializer::new_vec();
    buf.write_text_sz(s, sz).unwrap();
    buf.finalize()
}

fn cbor_bytes_sz(bytes: Vec<u8>, sz: cbor_event::StringLenSz) -> Vec<u8> {
    let mut buf = cbor_event::se::Serializer::new_vec();
    buf.write_bytes_sz(bytes, sz).unwrap();
    buf.finalize()
}
